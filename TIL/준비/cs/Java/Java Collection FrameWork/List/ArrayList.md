---
sticker: emoji//1f6a1
---
**ArrayList**
* 크기가 가변적인 선형 리스트, 저장용량이 존재함.  
	저장용량을 넘어서면 자동으로 증가시킴. 
* 특징
	1. 연속적인 데이터의 리스트(빈공간이 있으면 안됨.)
	2. 타입 안정성
		* ArrayList 는 제네릭을 사용하여 타입 안정성을 제공함.
		  ArrayList\<String\>  은 문자열만 저장할 수 있도록 함.
	3. 인덱스를 통한 빠른 접근
		ArrayList 는 인덱스를 사용하여 배열 요소에 빠르게 접근할 수 있음.
		데이터 검색이나 업데이트 시 유용함.
	4. 데이터 조작
		* ArrayList 는 요소를 추가, 삭제, 검색, 정렬 등 다양한 방법으로 데이터를 조작할 수 있는 메소드를 제공

**ArrayList vs 배열**

* 배열 장단점
	* **장점**
		1. 빠른 데이터 접근 : 배열은 인덱스를 통해 각 요소에 대한 빠른접근이 가능. 배열 요소를 읽거나 쓸 때 O(1) 의 시간복잡도를 가짐.
		2. 메모리 효율성 : 배열은 메모리를 연속적으로 사용하기 때문에 메모리 관리의 관점에서 효율적
		3. 간단한 구현 : 배열의 구현이 간단하기 때문에, 사용하기 쉽고 이해하기도 쉬움.
	* **단점**
		1. 고정된 크기 : 배열은 생성 시에 지정된 크기를 변경할 수 없음(정적할당)
		2. 삽입과 삭제의 비효율성 : 배열의 중간에 요소를 삽입하거나 삭제할 경우, 나머지 요소들을 이동시켜야 하기 때문에 O(n) 의 시간 복잡도를 가짐
		3. 메모리 낭비 : 배열의 크기를 정할 때 예측이 어려움

* ArrayList 장단점
	* **장점**
		1. 동적 크기 조정 : ArrayList의 요소가 추가될 때 내부 배열 크기가 부족하면 자동으로 크기 조정
		   
		2. 인덱스를 통한 빠른 접근 : 배열 기반이기 때문에 특정 인덱스의 요소에 대한 접근이 매우 빠름(일반적으로 O(1) 의 시간 복잡도)
		   
		3. API 편리성 : ArrayList는 List 인터페이스의 메소드들을 상속받기 때문에 다양하고 편리한 API를 제공(검색, 정렬, 순회 등)
		   
	* **단점**
		1. 삽입과 삭제의 비효율성 : 배열과 비슷
		   
		2. 메모리 오버헤드 : 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 크기 조정 시 현재 배열의 크기보다 큰 새배열을 생성하고 기존의 데이터를 복사하기 때문에, 잠시동안 추가적인 메모리를 사용
		   
		3. 동기화 되지 않음 : ArrayList 는 동기화가 되지 않음.->synchronized 가 없음... 대신 동기화를 위해서 Collections.synchronizedList(new ArrayList(...)); 를 해주면 됨.

**ArrayList , 배열 비교점**
* 타입 안정성 : 배열은 동일한 타입의 데이터만 저장가능, 배열은 Object 객체 타입만 저장할 수 있음. 기본 데이터 타입은 Wrapper 클래스 를 사용해야함.
  
* 크기 조정 : 배열은 고정 크기 , ArrayList 는 동적으로 조절 가능.
  
* 성능 : 배열은 크기가 고정되있고 메모리에 연속적으로 할당되기 때문에 데이터에 접근하는데 있어 ArrayList 보다 빠를 수 있음.
  
* 편의성 : ArrayList 는 add, remove, contains 등 다양한 메서드를 제공함.

---
## 메소드
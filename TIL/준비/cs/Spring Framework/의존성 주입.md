---
sticker: lucide//codepen
---
1. 스프링에서의 의존성 주입이란
2. 스프링에서는 어떻게 구현하는가?
3. 왜 의존성 주입을 사용해야 하는가?
4. DI 와 IoC
5. DI 와 DIP 


## 스프링에서의 의존성 주입이란
* 객체 지향 프로그래밍에서 중요한 기술.
* 객체가 다른 객체들에 의존할 때 필요한 의존 객체들을 외부에서 주입해주는 방법

### 의존성 주입 왜 씀?

1. **결합도 감소**
	객체들 사이의 의존 관계가 완화되어, 각 객체의 변경이 다른 객체에 미치는 영향을 줄일 수 있음.

2. **코드 재사용 증가**
	각 객체가 특정 구현에 덜 의존적이기 때문에, 다양한 시나리오에서 재사용할 수 있음.
   
3. **테스트 용이성 향상**
	의존성을 외부에서 주입할 수 있으므로, 테스트용 구현이나 모의 객체(Mock objects) 를 쉽게 주입하여 테스트가 용이해짐.   
   
4. **코드의 가독성 및 유지보수성 향상**
	의존성이 명확하게 구분되어 관리되므로, 코드의 이해와 수정이 쉬워짐.



## 스프링에서는 어떻게 구현하는가?
1. **생성자 주입**
	생성자를 통해 의존성을 주입받음. 객체가 생성될 때 필요한 모든 의존성이 제공되어야 하므로, 객체는 항상 완전하게 초기화 된 상태로 사용될 수 있음.

2. **세터 주입**
	세터 메소드를 통해 의존성을 주입받음. 이 방법은 객체 생성 후에도 의존성을 변경할 수 있어 유연성을 제공하지만, 객체가 완전히 초기화 되지 않은 상태로 사용될 가능성이 있음.

3. **필드주입**
	필드에 직접 의존성을 주입함. 이 방법은 코드가 간결해지지만, 테스트와 코드 재사용 측면에서는 권장되지는 않음.

_스프링 프레임워크는 이러한 의존성 주입 기능을 내부적으로 구현하기 위해 리플렉션, 프록시, 빈 라이프사이클 관리 등 다양한 기술을 사용함._


## 왜 의존성 주입을 사용해야 하는가?




## DI 와 IoC
제어의 역전에서 기재한 내용임.


## DI 와  DIP(Dependency Inversion Principle)
_의존성 역전원칙_

* 소프트웨어 아키텍처 원칙 중 하나로, 고수준 모듈이 저수준 모듈에 의해서는 안되고, 둘 다 추상화에 의존해야 한다는 원칙
* 세부사항(구현) 이 아닌 추상화(인터페이스) 에 의존해야함.


```java
public interface BookRepository{
	List<Book> findAll();
}

public class SqlBookRepository implements BookRepository{
	public List<Book> findAll() {
		// SQL 데이터베이스에서 책을 찾는 구현
		return new ArrayList<>();
	}
}

public class BookService {
	private BookRepository bookRepository;

	public BookService(BookRepository bookRepository) {
		this.bookRepository = bookRepository;
	}
	
	public List<Book> getBooks() {
		return bookRepository.findAll();
	}
}
```

위 코드에서 `BookService` 는 `BookRepository` 라는 추상화된 인터페이스에 의존함.

실제 구현체는 `SqlBookRepository` 이지만, `BookService` 는 구체적인 구현 대신 추상화된 인터페이스에만 의존함.

이로 인해서 다른 유형의 `BookRepository` 구현체로 쉽게 교체할 수 있게 되어, 시스템의 유연성과 유지보수성이 향상됨.


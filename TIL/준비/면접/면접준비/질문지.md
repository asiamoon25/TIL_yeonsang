


# 네트워크

* https://www.google.com/ 을 접속할 때 일어나는 일
	* https:// 등 프로토콜 확인
	* https or http 면 DNS Lookup 실행
	* host file -> DNS Cache 순서로 IP 찾음.

* TCP vs UDP
	* 약간 동기와 비동기 느낌
	* TCP 는 연결 지향, UDP 는 비연결형
	* UDP 는 TCP 보다 빠르지만 신뢰성이 떨어짐 
	* TCP 는 연결을 받았다는 수신 확인을 받음.
	* TCP 는 데이터의 정확성과 순서가 중요한 곳에 사용되며, UDP 는 속도와 효율성이 더 중요한 경우에 적합함.

* TCP 3,4 way handshake
	* 3 way handshake
		* 상대방 컴퓨터와 사전에 세션을 수립하는 과정
			* Clinet > Server : TCP SYN
			* Server > Client : TCP SYN ACK
			* Client > Server : TCP ACK
	* 4 way handshake?
		* Server 에서 client 에게 무작위 랜덤값을 주고 
		* 클라이언트는 받아서 응답준비를 함.
		* 클라이언트는 무작위 랜덤값과 자신의 랜덤값을 사용하여 하나의 키를 생성함.
		* 클라이언트는 자신의 랜덤값과 함께 코드를 server 에 보냄.
		* 코드는 클라이언트가 올바른 하나의 키를 가지고 있음을 확인하는데 사용됨.
		flag 보내고 수신완료 ack 보내고, 통신을 종료하기 위한 요청을 보낸 뒤 client 에서 수신완료 ack를 보내면 연결이 종료됨.
		* 상호 인증 : 클라이언트와 서버가 서로를 인증함.
		* 암호화 키 설정 : PTK 와 GTK 를 설정하여 안전한 데이터 통신을 보장함.
		* 무결성 검증 : MIC 를 통해 메시지의 무결성을 확인함.

* Http vs Https
	* 보안성
		* HTTP : 데이터를 암호화하지 않고 평문으로 전송함.
		* HTTPS : SSL/TLS 를 사용하여 데이터를 암호화 하여 전송함.
	* 포트번호
		* HTTP : default 80 port
		* HTTPS : default 443 port
	* 인증서
		* HTTP : `http://` 로 시작
		* HTTPS : `https://` 로 시작

	현재 SSL 은 더 이상 사용되지 않으며, 현대의 HTTPS 는 모두 TLS 를 사용함.
	
	인증 프로세스 
		1. 사용자 : 사이트 접속
		2. 사이트 : 발급받은 인증서 사용자쪽으로 줌
		3. 사용자 : 인증기관의 공개키로 해독
		4. 사용자 : 대칭키 생성
		5. 사용자 : 암호화 하여 전송
		6. 사이트 : 사이트 개인키로 암호화된 대칭키 해독

* **Https에 대해서 설명하고 SSL HandShake 에 대해서 설명**
	* 
	  
	* SSL HandShake
		* Client Hello : 클라이언트가 서버에 연결 요청을 보냄. 지원하는 SSL/TLS 버전, 암호화 알고리즘, 임의의 데이터를 포함.
		* Server Hello : 서버가 클라이언트 요청에 응답함. 선택된 SSL/TLS 버전, 암호화 알고리즘, 서버의 인증서를 포함
		* 서버 인증 및 키 교환
			* 서버는 자신의 인증서를 클라이언트에게 보냄. 인증서는 서버의 공개 키가 포함되어 있음.
			* 서버는 키 교환 방법을 제안함.
		* Client 키 교환
			* 클라이언트는 서버의 공개 키를 사용하여 대칭 키를 암호화한 후 서버에 전송함.
			* 서버는 자신의 개인 키로 암호화된 대칭 키를 복호화하여 세셔 키를 얻음.
		* 암호화된 연결 설정
			* 클라이언트와 서버는 대칭 키를 사용하여 암호화된 통신을 시작함.
		* 이후의 통신은 모두 대칭 키 암호화로 보호됨.


* GET 과 POST 의 차이
	* GET
		* query string 방식
			* url 뒤에 ? 와 &로 이어진 쿼리스트링으로 데이터 전송
			* 데이터의 양의 제한이 있음.
		* 정보 조회 용
	* POST
		* body 에 담는 방식
			* Request Body 에 담아서 인코딩 되어 전송됨.
			* 데이터 양의 제한이 GET 방식보다는 큼.
		* 서버 데이터 변경 용

*  HTTP method 와 이것이 하는 역할에 대해서 설명
	* 음.. 제가 아는건 GET, POST, PUT, DELETE, OPTION 입니다.
		* GET 은 데이터 조회
		* POST 는 데이터 생성
		* PUT 은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성함. CRUD 로 따지면 C, U 임.
		* DELETE 요청은 서버에 데이터를 제거할 것을 요청함.
		* OPTION 은 해당 URI 에 대해 서버가 허용하는 메서드 확인 용.

* RESTful 이란 뭐임?
	* 음... 저도 아직은 잘 모르지만 URI 를 통해 자원을 표시하고 HTTP Method 를 통해 자원에 대한 처리를 표현한다고만 알고 있음.

* CORS 란?
	* 서로 다른 도메인간 데이터 교환이 이루어질 때 나는 것.
	* 서버 측에서 해결할 수 있음.
		* 저 같은 경우에는 CORS filter 를 만들어서 요청이 들어올 때 허용하는 url 만 true 로 해서 허용하는 방식으로 했습니다.


----

# OS (운영체제)

* 프로세스와 스레드의 차이
	* 프로세스
		* 실행중인 프로그램
	* 스레드
		* 실행 제어만 분리한 것
	* 차이점
		* 프로세스는 운영체제로 부터 자원을 할당 받지만, 스레드는 프로세스로부터 자원을 할당받고, 프로세스의 코드/데이터/힙 영역을 공유하기 대문에 좀 더 효율적으로 통신할 수 있음.


* 컨텍스트 스위칭
	* 한 Task 가 끝날 때 까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법
	  
	* 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작함.

* 동기와 비동기의 차이, 장단점
	* 차이
		* 동기
			* 메서드 리턴과 결과를 전달 받는 시간이 일치하는 명령 실행 방식
			* 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같음.
		* 비동기
			* 여러 개의 처리가 함께 실행되는 방식으로, 동기 방식에 비해 단위 시간 당 많은 작업을 처리할 수 있음.
			* 단, CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있음. 프로그램의 복잡도도 증가하게 됨.


* 멀티쓰레드 프로그래밍
	* 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 멀티 스레드 프로그래밍이라고 함.
	* 장점
		* 멀티 프로세스에 비해 메모리 자원소모가 줄어듬
			* 왜? 
				* 스레드는 프로세스로부터 자원을 할당 받고, 프로세스의 코드/데이터/힙 영역을 공유함.
		* 힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단함.
		* 스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭 보다 빠름.
	* 단점
		* 힙 영역에 있는 자원을 사용할 때는 동기화를 해야함.
		* 동기화를 위해서 락을 과도하게 사용하면 성능이 저하될 수 있음.
		* 하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있음.
	* 그러면 Thread-Safe 하다라는 말은?
		* 두 개 이상의 스레드가 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미함.
			* java.util.concurrent 패키지 하위의 클래스를 사용함.
			* 인스턴스 변수를 두지 않음.
			* Singleton 패턴을 사용함. -> 일반적인 Singleton은 Thread-safe 하지 않음.
			* synchronized 블럭에서 연산을 수행함.

* 데드락 방지
	* 발생조건을 알아야됨.
		* 상호 배제 : 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야함.
		* 점유 대기 : 할당된 자원을 가진 상태에서 다른 자원을 기다림.
		* 비선점 : 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없음.
		* 순환대기 : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음.
	* 해결방법
		* 예방 : 4가지 조건 중 하나라도 만족되지 않도록 함.
		* 회피 :  알고리즘을 데드락이 발생하지 않도록 함.
		* 회복 : 교착 상태가 발생할 때, 해결함 
		* 무시 : 회복과정의 성능저하가 심하다면 그냥 무시함.

* 기아 상태
	* 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원이 할당 되지 않는 경우
		* 우선순위 변경


* 시간 복잡도란?
	* 입력값과 연산 수행 시간의 상관관계를 나타내는 척도를 시간 복잡도


---


# DB

* 인덱스를 사용하는 이유
	* 인덱스 없이 full scan 을 할 경우 쿼리 조회 시 시간이 오래 걸림.
	* 장점
		* 검색이 빠름
	* 단점
		* insert, update 시 자원이 많이 들어감


* 트랜잭션이란?
	* DB 의 상태를 변화시키는 하나의 논리적인 작업 단위
		* 수행 중 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있음.

* ACID
	* Atomicity
		* 트랜잭션의 연산은 모든 연산이 완벽하게 수행
	* 
- 객체지향에 대해 설명해주세요
- 추상화에 대해 설명해주세요
- MVC 패턴에 대해 설명해주세요
- 데이터베이스 옵티마이저에 대해 설명해주세요
- 풀스캔(FULL SCAN)에 대해 설명해주세요
- 코드 리팩토링의 의미가 무엇일까요?
- 자바의 컬렉션에 대해 설명해주세요
- Java 8에서 Stream을 사용해보셨나요?
- 가비지 컬렉션 알고리즘에 대해 설명해주세요
- 배열 안 중복제거를 위한 방법이 뭐가 있을까요?
- Spring DI에 대해 설명해주세요
- JPA를 사용하면 좋은점?
- JWT에 대해 설명해주세요, 사용하면 장점과 단점?
- MSA란 무엇인가요? 장점과 단점을 말씀해주세요
- Enum 사용해보셨나요? Enum이란 무엇인가요?
- equals를 오버로딩하여 사용해봤나요? hashCode란 무엇인가요?
- 자바 reflection에 대해 설명해주세요
- REST API란? REST API 명령어(CRUD) 아시는것 설명해주세요.
- 자바의 장점과 단점을 설명해주세요
- 세션과 쿠키의 차이는?

---

## 답변


### 기본 질문
* 객체 지향에 대해서
	* 객체를 기준으로 코드로 나누어 개발
* 추상화
	* 공통 기능 추상화 -> interface 와 abstarct 가 있음.
* MVC 패턴
	* Model
		* 데이터 조작
	* View 
		* 사용자 인터페이스 요소 담당
	* Controller
		* 사용자 입력을 처리하고, 모델과 뷰를 연결하는 중재자 역할을 함.
* 데이터베이스 옵티마이저
	* DB 의 CPU 같은 것
	* 쿼리 실행 계획
* Full Scan
	* 전체 조회
	* 조건절 없이
	* 인덱스 없으면 폭망
* 코드 리팩토링의 의미
	* 코드 개선
	* 가독성 증가
	* 운영 관리 쉽게
* Collection 이란?
	* 예전에는 Vector 이런 애들이 있었고 각각의 메서드가 달라서 코드 가독성이 떨어졌었음. addElement 등등... 그래서 공통 인터페이스를 구현해서 데이터 관련 처리를 한 곳으로 묶은게 Collection
	* 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화 하여 클래스로 구현
	* Collection 을 구현한 애들
		* Map
		* List
		* Queue
		* Set
* Stream 사용 여부
	* 예
		* 원본 데이터 소스를 변경하지 않음. 조회만 함.
		* 일회용 : 한번 사용하면 닫혀서 재사용 불가
		* 최종 연산 전까지 중간 연산을 수행하지 않음.
		* 병렬 처리가 쉬움
* GC 알고리즘
	* 8 이하까지는 Mark-Sweap-Compact 라는걸 쓰는걸로 알고 있음.
	* Mark-Sweap-Compact 란
		* GC 대상이 될 대상 객체를 식별(Mark) 하고 제거(Sweep) 하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction) 을 수행함.
	* 8 이후는 다른 방식으로 한다고 하는데 아직 잘 모르겠다.
* 배열 안 중복 제거
	* stream의 distinct 를 쓰면 된다.
* Spring DI 란?
	* DI 의존성 주입
		* Bean 객체를 개발자가 아닌 Spring 에서 자동으로 해줌
		* 생성자 주입, 세터 주입, field 주입






### 자료구조 / 알고리즘

* 시간 복잡도 계산
	* 내가 풀었던 코테 문제 시간 복잡도 계산
* 배열과 링크드 리스트의 차이
	* array 와 LinkedList 의 차이는 array는 생성 시 메모리에 이 할당된 상태로 정해진 길이를 가지고 초기화 된다는 거고, LinkedList 는 메모리에 포인터를 가지고 그것을 바라보고 있다고 보면 된다.
	* 배열은 인덱스로 조회할 수 있기 때문에 인덱스 조회 성능이 높고, 데터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있음.
	* 링크드리스트는 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다는 장점.
* List 와 Set 의 차이점.
	* List 는 선형 자료구조
	* Set 은 중복을 허용하지 않음.순서를 유지하지 않음.
* Hash Function, HashTable 에 대해서 설명
	* Hash Function
		* 임의의 크기를 가진 데이터를 고정된 크기의 값(해시코드 또는 해시 값) 으로 매핑하는 함수.
			* **특징**
				* 고정된 크기 : 입력 데이터를 고정된 크기의 해시 값으로 변환
				* 결정론적 : 동일한 입력에 대해 항상 동일한 해시 값을 반환
				* 빠른 계산 : 해시 함수는 빠르게 계산 되어야 함.
				* 균등 분포 : 해시 값이 가능한 고르게 분포되어야 해시 테이블의 성능이 향상됨.
			* **사례**
				* 데이터베이스 인덱싱
				* 암호화
				* 데이터 무결성 검증
				* 해시 테이블에서 키-값 매핑 등
	* Hash Table
		* 해시 테이블은 배열과 해시 함수를 결합한 자료구조
			* **특징**
				* 빠른 검색 : 평균적으로 O(1) 시간 복잡도로 데이터 검색이 가능.
				* 충돌 처리 : 서로 다른 데이터가 동일한 해시 값을 가질 수 있으며, 이를 충돌이라고 함.
	* 차이점
		* 해시 함수 : 데이터를 함수 값으로 변환
		* 해시 테이블 : 해시 값을 사용하여 데이터를 효율적으로 저장하고 검색하는 자료 구조


* Stack, Queue 설명
	* Stack
		* 후입 선출 하는 자료구조
			* 뒤로가기 실행 취소 등이 있음.
	* Queue
		* 선입 선출 하는 자료구조
			* 인쇄 대기 등
* Heap, Priority Queue
	* Priority Queue
		* 우선순위 큐..
		* 우선순위 큐는 각 요소가 우선순위를 가지는 데이터 구조입니다. 일반적인 큐(FIFO)와 달리, 우선순위 큐에서는 우선순위가 높은 요소가 먼저 처리됩니다.
			* 힙을 사용하여 구현이 가능
			* 삽입과 삭제 연산의 시간복잡도는 힙과 동일하게 O(log n)
			* 응용 프로그램에서 작업 스케줄링, 시뮬레이션 시스템, 다익스트라 알고리즘 등에 사용됨.
	* Heap
		* 완전 이진 트리 구조를 가지며, 각 노드의 값이 특정 순서에 따라 정렬된 자료구조
			* 최소 힙
				* 부모 노드의 값이 자식 노드의 값보다 크거나 같도록 유됨.
				* 루트 노드의 값이 항상 가장 큼.
			* 최대 힙
				* 부모 노드의 값이 자식 노드의 값보다 작거나 같도록 유지
				* 루트 노드의 값이 항상 가장 작음.
		* **특징**
			* 완전 이진 트리이므로, 배열로 쉽게 구현이 가능
			* 삽입과 삭제 연산의 시간 복잡도는 O(log n) 임.
			* 힙은 우선순위 큐를 효율적으로 구현하는데 사용됨.

* Tree, Binary Tree, BST, AVL Tree
	* Tree
	* Binary Tree
		* 데이터베이스 및 파일 시스템에서 인덱승을 위해 널리 사용되는 자료구조
		* 데이터의 삽입,삭제,검색 등의 작업을 지원하기 위해 설계됨.
		* **특징**
			* 균형 유지
				* 모든 리프 노드는 루트에서 동일한 거리에 있음.
				* 균일한 검색 시간을 보장함.
			* 분할 및 병합
				* 노드의 데이터가 가득 차거나 비워질 때 자동으로 노드를 분할하거나 병합함. -> 트리의 균형을 유지하는데 도움을 줌.
	* BST (이진 탐색 트리)
		* 각 노드가 최대 두 개의 자식을 가지는 이진 트리의 일종
			* 1. 노드의 왼쪽 서브트리에는 해당 노드의 키보다 가장 작은 키를 가진 노드들만 포함됨.
			* 2. 노드의 오른쪽 서브트리에는 해당 노드의 키보다 큰 키를 가진 노드들만 포함됨.
			* 3. 왼쪽과 오른쪽 서브트리도 각각 이진 탐색 트리임.
	* AVL Tree
		* 자가 균형 이진 탐색 트리의 일종
		* 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1이 되도록 유지하는 특성을 가지고 있음.

* BST 의 최악의 경우의 예시와 시간복잡도에 대해서 설명
	* 이진 탐색 트리의 모양이 연결 리스트와 닮아지는 현상이 있음.
		* 이 때의 시간 복잡도는 O(N) 의 시간 복잡도를 가짐.
	* 예시
		* 1,2,3,4,5 순서대로 삽입 시

* 피보나치 수열을 코드로 구현하는 방법
	* 재귀호출
	* DP


* JVM 의 구조와 JAVA 의 실행 방식
	* JVM
		* Class Loader
			* JVM 내로 Class 를 로드하고 링크를 통해 배치하는 작업을 수행
		* 실행 엔진
			* byte code 를 실행 시킴
		* Runtime Data Areas
			* 프로그램 실행 중에 사용되는 다양한 영역
				* PC Register
					* Thread 가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 가지고 있음.
				* Stack Area
					* 지역 변수, 파라미터 등이 생성되는 영역
				* Heap Area
					* 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC 의 대상
				* Method Area
					* 클래스의 멤버 변수, 메소드 정보, Type 정보, 등이 생성됨. 모든 Symbolic Reference 를 포함.
		* JNI(Java Native Interface)
			* 자바 애플리케이션에서 C,C++ 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공해줌.
				* 대표적으로 Thread 의 currentThread()
		* Native Method Library
			* C,C++ 로 작성된 라이브러리
	* Java 의 실행 방식
		* Java 컴파일러가 .java 를 읽어 .class 로 변환
		* Class Loader 를 통해 .class 파일들을 JVM 으로 로딩
		* 로딩된 class 파일들을 Executtion Engine 을 통해 해석됨.
		* 해석된 바이트코드는 Runtime Data Area 에 배치되어 실질적인 수행이 이루어짐.
* GC 란 무엇인가? 동작 방식은?
	* Garbage Collector 로 Heap 영역에 있는 사용하지 않는 객체들을 정리하여 메모리 정리를 함.
	* 동작 방식
		* YG 영역(Minor GC)
			* YG 는 에덴 영역과 survivor1, survivor2 영역이 있음. Minor GC 가 실행될 때는 Eden 에 있는 객체들 중 삭제될 객체들 제외 사용 중인 객체들은 survior1 영역으로 이동하며 Eden 의 영역은 정리가 됨. 이 후에 다시 Minor GC 가 실행되면 위 방식과 동일하게 survivor 2 로 옮긴 후 삭제 과정이 이루어지고 오래 있는 애들 age count 가 높은 애들은 OG 영역으로 이동함.
		* OG 영역(Major GC)
			* OG 영역에서 GC 가 실행될 때는 Mark-Sweap-Compact 과정이 일어나며 이 때 애플리케이션은 정지하게 된다. Mark-Sweap-Compact 는 사용하지 않는 객체 Unreachable 한 객체들은 mark 가 되고 (sweap) 삭제 된 후 사용 중인 애들은 Heap 영역에 앞쪽으로 와서 정리가 된다(Compact) 

* Collection Framework
	* 자바 Collection Framework 는 객체, 데이터 들을 효율적으로 관리 할 수 있는 자료 구조들이 있는 라이브러리를 컬렉션 프레임 워크라고 함.
	* List,Set 은 Collection 인터페이스를 구현하지만, Map 인터페스는 구조상의 차이라 별도로 정의한다.

* Generic 이란?
	* Generic 타입 및 메소드를 정의하고 사용할 수 있는 언어적 특성입
	* List<Integer\> 에서 꺽새에 들어가는 부분이라고 생각하고 있습니다. 
		* 파라미터 타입이나 리턴 타입에 대한 정의를 외부로 미룸
		* 타입에 대해 유연성과 안정성을 확보함.
		* 런타임 환경에 아무런 영향이 없는 컴파일 시점의 전처리 기술
			* **장점**
				* 제네릭을 사용하면 잘못된 타입을 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있음.
				* 클래스 외부에서 타입을 지정해주기 때문에 관리하기 편함.
				* 코드의 재사용성이 높아짐.

* 어노테이션에 대해서 설명해주세요
	* 사전적 의미로 주석이지만 주석과 다른점은 코드를 작성할 수 있습니다.
	* 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것입니다.
	* 역할로써는 컴파일러에게 문법 에러를 체크하도록 정보를 제공하고 프로램을 빌드할 때 코드를 자동으로 생성할 수 있도록 정보를 제공합니다.


* 오버로딩과 오버라이딩의 차이
	* 오버라이딩은 클래스를 상속 받아서 메서드를 구현할 때 사용하는 걸로 알고 있고 오버라이딩은 메소드를 이름은 같지만 파라미터를 다르게 받을 때 사용함.

* 인터페이스와 추상클래스의 차이점
	* 인터페이스는 Flyable, Drawable 같이 행동을 정할 수 있지만 그 행동이 어떻게 수행되어야 하는지에 대해서는 명시하지 않습니다. 왜냐하면 추상 메소드만 있기 때문입니다.
	* 인터페이스는 다중 상속이 가능하지만, 추상 클래스를 상속하는 경우 단일 상속만 가능합니다.


* 클래스는 무엇이고 객체는 무엇?
	* 클래스는 객체를 정의하는 틀 또는 설계도
	* 객체는 식별 가능한 개체 또는 사물

* static 이란? 
	* 최초 클래스를 로드할 때 메모리에 할당해 종료될 때 해제 되는 것을 의미합니다.
	* GC 의 관리를 받지 않는 method area 에 저장이 되고 프로그램 종료 시까지 유지됩니다.
	* 클래스 레벨 내에 공유 됩니다.

* 자바의 원시타입들 과 각 바이트
	* boolean, char, short, int, long, double, float 이렇게 알고 있습니다.
	* boolean (1), char(2), short(2), int(4), log(8), float(4), double(8)

* 접근 제어자의 종류와 이에 대해서 설명해주세요.
	* public, private, protected
	* 클래스는 public, private, 클래스 멤버 접근 제어자는 protected, private 이렇게 있습니다.
	* public
		* 어떤 클래스에서든 접근 가능
	* default
		* 같은 패키지
	* protected
		* 같은 패키지 내의 다른 클래스 또는 다른 패키지의 자식 클래스에접근 가능
	* private
		* 해당 클래스 내에서만 접근 가능
		* 가장 제한적이 접근 수준


* ⭐SOLID⭐
	* SRP 단일책임 원칙
		* 하나의 클래스는 하나의 책임만 가져야 함.
	* OCP
		* 클래스 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다는 원칙
	* LSP (리스코프 치환 원칙)
		* 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
	* ISP
		* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다는 원칙
	* DIP
		* 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화 의존해야 한다는 원칙
* 동일성과 동등성(equals(), == 의 차이)
	* equals 는 객체가 서로 같은 주소를 바라보고 있는지 확인
	* == 은 내용이 같은지 확인.
* 원시 타입과 참조 타입
	* JAVA 에서 단 8개 밖에 존재하지 않는 타입(boolean, char, short, int, long, float, double)
	* 그 외는 모두 참조 타입 Object 클래스 이거나 이를 상속하는 애들
	* Object 는 null 을 가질 수 있지만 원시타입은 항상 값이 있어야 함.

* String, StringBuilder, StringBuffer 의 차이
	* String
		* String 은 불변입니다. SgringBuilder 와 StringBuffer 는 이런 String 의 특징 때문에 사용하는 가변 타입.
	* StringBuilder 는 Thread-safe 하지 않음.
	* StringBuffer 는 Thread-safe 함.

* Checked Excetion vs UnChecked Exception
	* Checked Exception 은 RuntimeException의 하위 클래스가 아니면서 Exception 클래스의 하위 클래스들
		* 체크 예외의 특징은 반드시 에러 처리를 해야하는 특징(try/catch)
	* Unchecked Exception
		* RuntimeException 의 하위 클래스
			* 예외 처리를 강제하지 않음.
				* ArrayIndexOutOfBoundException
	* Spring Transaction 에서 rollback 대상이 되는 예외는 RuntimeException 을 받는 Unchecked Exception 임.



* JAVA 8 에서 추가된 기능
	* 람다 표현식
	* LocalDate, LocalTime 및 LocalDateTime 사용
	* Stream API, Optional


* try-with-resource 에 대해서 설명
	* try() <- 이렇게 try 문에 들어가는 애들
	* 리소스가 있는지 없는지 잘 끝나서 close 가 되었는지 확인하기 위한 용도

* 강한 결합과 느슨한 결합
	결합은 의존성의 정도 -> 어떤 모듈이 다른 모듈의 필수 정보만 알고 있을 때는 느슨하다고 하고 필수 정보 외 세세한 정보(구현 세부사항)까지 알고 있으면 강한 결합이라고 함.



---

### Spring

* Spring DI/IoC 는 어떻게 동작?
	* IoC 객체의 생성 및 관리 책임을 개발자에서 전체 애플리케이션 또는 프레임워크에 위임하는 디자인 원칙
	* DI 는 의존성 주입은 객체가 필요로 하는 의존성 -> 외부에서 주입받는 방식을 사용.
		* 의존성 주입은 생성자 주입, 세터 주입, 필드 주입 등 다양한 방법으로 수행될 수 있음.

* Spring Bean 이란? 
	* 스프링에서 객체를 빈이라고 부르며, 스프링 IoC 컨테이너가 관리하는 객체임.
	* 빈 생명주기와 의존성은 컨테이너에 의해 관리됨.
	* 어노테이션과 xml 을 통한 빈정의


* Spring Bean 생성과정
	* 객체 생성 -> 의존설정 -> 초기화 -> 사용 -> 소멸

 * Spring Bean Scope
	 * 해당 빈 인스턴스의 생명 주기와 가시성을 정의함.
		 * 싱글톤 : 기본 값으로, Spring IoC 컨테이너 당 단 하나의 인스턴스만 생성됨.
		 * 프로토타입 : 요청할 때마다 새로운 Bean 인스턴스가 생성됨.
		 * 리퀘스트 : HTTP 요청당 하나의 Bean 인스턴스가 생성됨.
		 * 세션 : HTTP 세션당 하나의 Bean 인스턴스가 생성됨.
		 * 글로벌 세션 : 포털 애플리케이션에서 사용되며, 전역 HTTP 세션 당 하나의 빈 인스턴스가 생성됨.

* Spring IoC Container 의 역할
	* 설정 정보를 바탕으로 객체를 생성하고, 관리하며, 의존성을 주입하는 역할을 함.
	* 빈 인스턴스 생성, 의존성 관리, 빈 생명주기 관리, 빈 설정


* DI 종류는 어떤것이 있고, 이들의 차이
	* 생성자 주입
		* 불변 초기화 때부터 즉각적인 사용이 가능함.
	* setter 주입
		* setMethod 를 통해 주입 후 사용이 가능함.
		* 객체 생성 후에도 의존성을 변경할 수 있어서 유연성이 높다.
	* field 주입
		* 필드에 직접 의존성을 주입함. @Autowired -> 코드가 간결해지만, 테스트와 코드 재사용 측면에서는 권장되지 않음.

* Autowiring 과정에 대해서 설명
	* 컨테이너에서 타입(인터페이스 또는 오브젝트) 을 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입함.

* Spring Web MVC 의 Dispatcher Servlet 의 동작 원리에 대해서 간단하게

* Servlet Filter 와 Spring Interceptor 의 차이점
	* interceptor
		* 요청/응답 또는 메서드 호출 전후 처리
		* Spring Context 내에서 동작
	* filter 
		* HTTP 요청/응답 전후 처리
		* 서블릿 컨테이너 내에서 동작

* Spring 에서 CORS 해결
	* Custom Filter 구현해서 해당 url 만 허용해주면 된다.

* Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명
	* 둘다 IoC 컨테이너에서 Bean 을 등록하기 위해 사용됨.
	* Bean 
		* method 단위
		* 싱글톤으로 1회 생성
	* Component
		* 클래스 단위
		* 1회 싱글톤으로 생성

* Spring Web MVC 에서 요청마다 Thread  가 생성되어 Controller 를 통해 요청을 수행할 텐데, 어떻게 1개의 Controller 만 생성될 수 있을까요?
	* @Controller 상위는 @Component 여서 싱글톤으로 1회 생성됨.


* Filter 는 Servlet 의 스펙이고, Interceptor 는 Spring MVC 의 스펙임. Spring Application 에서 Filter 와 Interceptor 를 통해 예외를 처리할 경우 어떻게 해야함?
	* Filter 는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생했을 때 ErrorController 에서 처리해야함.
	* Interceptor 는 @ControllerAdvice 를 적용해서 처리할 수 있음.

* 의존성과 설정값을 생성자 인자로 주입해야하는 이유
	* 모든 의존성을 생성자를 통해 주입하면, 인스턴스 생성 시 즉시 어떠한 동작을 실행할 수 있음. 또한 추가적인 설정은 필요 없으며, 뜻하지않게 의존성과 설정값을 빠뜨리는 일이 발생하지 않고 테스트에도 용ㅣ이함.

---

### JPA

* JPA 의 영속성 컨텍스트의 이점(5가지) 설명해주세요.
	1. 1차 캐시 기능
		* 영속성 컨텍스트는 1차 캐시에 저장하여 같은 트랜잭션 내에서는 같은 엔티티를 조회할 때 데이터베이스를 다시 조회하지 않고 캐시된 엔티티를 반환함.
	2. 변경감지(Dirty Checking)
		* 영속성 컨텍스트는 엔티티의 변경 사항을 추적함. 트랜잭션이 끝날 때 변경된 엔티티를 자동으로 감지하여 데이터베이스에 반영함.
	3. 쓰기 지연(Batching)
		* 데이터베이스에 직접 쿼리를 보내지 않고, 트랜잭션이 커밋될 때 까지 쿼리를 모아서 한 번에 보내는 쓰기 지연 기능을 제공함.
		* 이를 통해 네트워크 및 데이터베이스 부하를 줄이고 성능을 개선할 수 있음.
	4. 엔티티 식별 보장
		* 같은 엔티티 식별자(PK) 를 가진 엔티티 객체를 하나로 보장함.이는 동일한 트랜잭션 내에서 동일한 엔티티를 여러 번 조회하더라도 같은 객체를 반환하여 일관성을 유지할 수 있게 함.
	5. 지연로딩(Lazy Loading)
		* 엔티티의 연관된 엔티티를 실제로 필요한 시점까지 데이터베이스에로딩하지 않고 프록시 객체를 통해 지연 로딩을 지원함. 불필요한 데이터베이스 접근을 줄이고 성능을 최적화 할 수 있음.
* JPA Propagation 전파단계 설명
	* 잘 모르겠는데요.

* JPA 를 쓴다면 그 이유에 대해서 설명
	* RDBMS 에 의존하는게 아니라 자바 코드로 표현될 수 있기 때문에 사사용합니다. -> 생산성이 높아짐.

* N+1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명
	* N 개의 부모 엔티티와 각각의 부모 엔티티에 관련된 자식 엔티티들
		* join 때릴 때
	* 원인
		* 모든 부모 엔티티를 가져오는 단일 쿼리 실행됨.
			* `SELECT * FROM posts` 
		* 각 부모 엔티티에 대해 관련된 자식 엔티티를 가져오기 위해 추가 쿼리가 실행됨. 예를 들어 각 `posts` 에 대해 `SELECT * FROM comments WHERE post_id = ?`
		* 이 때, 만약 10개의 포스트를 가져오면, 총 11개의 쿼리가 실행됨. (1개의 부모 쿼리 + 10개의 자식 쿼리)
	* 해결방법
		* Eager Loading
			* 처음부터 필요한 모든 데이터를 한꺼번에 가져오는 방법
		* 데이터 모델링 최적화
			* 데이터 정규화나 역정규화를 통해 자주 사용하는 데이터를 함께 저장함.
		* JPQL 의 FetchJoin 을 사용



---
### 인프라 / 클라우드

* 로드밸런서에 대해서 설명
	* 서버에 가해지는 부하를 분산해주는 장치 또는 기술을 통칭
  
* 리버스 프록시에 대해서 설명
	* 웹 서버 앞에 위치하여 클라이언트 요청을 해당 웹서버에 전달
	* 기존 정방향 프록시는 클라이언트 앞에 있음.
	* 방향 프록시는 원본 서버 앞에 위치하며 어떤 클라이언트도 원본 서버와 직접 통신하지 못 하도록 합니다.
  
* 무정지 시스템으로 가기 위해 필요한 방법에 대한 생각
	* Rolling
		* 서버를 빼고 다시 넣는 작업
	* Canary
		* 소수의 유저만 허용하는 서버에 미리 배포 후 이상 없으면 모든 서버에 배포
	* Blue/Green
		* 실 서비스 환경 Blue, 새롭게 배포할 환경 Green 을 세트로 준비해서 배포하는 형식
  
---
### Container
* Docker 란 무엇이고 컨테이너 가상화를 왜 할까
	* 가상화 플랫폼
		* 일관성 있는 개발 환경
		* 이식성
		* 효율성
		* 확장성
		* 격리
	* 위 장점이 있어서 사용
  
* Container 환경에서의 디버깅은 어떻게 하며 상대적으로 어려운 점은 어떤거?
	* 로컬 개발 환경과 컨테이너 런타임 환경이 다를 수 있어, 로컬에서 재현되지 않는 문제가 컨테이너 환경에서 발생할 수 있음.

---
### 디자인 패턴

* 싱글톤 패턴
* EDD
* MSA

---

### DevOps

* CI/CD 란 무엇, 장점은 무엇
	* CI
		* 지속적 통합 -> 개발자가 코드 변경사항을 공유 리포지토리에 정기적으로 병합하는 것을 의미
	* CD 
		* 지속적 배포 -> 개발된 소프트웨어를 자동으로 테스트하고 운영환경에 배포하는 과정을 의미함.

* DevOps 란 무엇인가
	* 소프트웨어 개발과 IT 운영을 결합한 것

---

다시...


### 데이터베이스

* 인덱스를 사용하는 이유
	* 인덱스를 사용하는 이유는 검색성능을 향상 시키기 위해서입니다.
	* 인덱스의 장점은 빠른 검색성능을 들 수 있습니다.
	* 단점으로는 Insert, Update, Delete 시에는 추가적인 연산이 수행됨.

* 트랜잭션이란?
	* 데이터베이스의 상태를 변화 시키는 하나의 논리적인 작업단위, 트랜잭션이 한번 실패하면 전부 실패 하고, 모두 성공해야 성공이라고 할 수 있음.

* ACID에 대해서 설명해주세요
	*  ACID 는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질임.
	* A -> 원자성
		* 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라 실패하면 트랜잭션 내의 모든 연산은 실패해야함.
	* C -> 일관성
		* 트랜잭션은 유효한 상태로만 변경될 수 있음.
	* I -> 고립성
		* 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 함.
	* D -> 내구성
		* 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태유지되는 것을 보장해야함. -> 비휘발성 메모리에 데이터가 저장되는 것을 의미함.

* 트랜잭션 격리수준에 대해서 설명
	* 고립도와 성능의 트레이드 오프를 조절함.
	* READ UNCOMMITTED : 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.
	* READ COMMITTED : 다른 트랜잭션에서 커밋된 내용만 참조할 수 있음.
	* REPEATABLE READ : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.
	* SERIALIZABLE : 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.

* 정규화에 대해서 설명
	* 정규화는 데이터의 중복 방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미함.

* RDBMS vs NoSQL
	* 정형 데이터 vs 비정형 데이터
	* RDBMS 는 중복데이터 방지, NoSQL 은 중복을 허용함.

* Redis 에 대해서 간단히 설명해주세요.
	* NoSQL DB , 전역 캐시
	* 스프링에서는 세션과 캐싱을하는데에 자주사용됨.

* Redis 와 Memcached 차이
	* Redis 는 전역 캐시, Memcached 는 지역 캐시
	* Redis 는 싱글스레드, Memcached 멀티 스레드 지원
	* Redis 는 다양한 자료구조 지원, memcached 는 문자열만.

* Elastic Search 에 대해서 간단히 설명
	* Elastic Search 는 검색엔진. 보통 단독으로 사용하기 보다는 ELK 스택이라부르는 LogStash, Kibana, Beats 를 추가적으로 사용함.

* CAP 이론
	* 일관성, 가용성, 분할 내성의 약자이며, 이 세 가지 속성 중에서 동시에 모두를 만족시킬 수 없다는 이론
	* 일관성은 -> 데이터 저장하는 장비가 1대 또는 100대 이던지 간에 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 속성
	* 가용성 -> 죽지 않은 상태의 모든 서버는 클라이언트에게 항상 정상 처리 응답을 보내주어야 한다는 것을 의미함.
	* 분할 내성은 클러스터가 여러 대 동작하고 잇을 때 해당 클러스터 사이에 접속이 단절되어 서로 통신할 수 없는 상황에서도 시스템 잘 동작해야 한다는 것
* 

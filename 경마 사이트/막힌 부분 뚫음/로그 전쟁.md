7일 째 로그만...

나는 Controller 나 Service 쪽으로 요청이 들어오면 AOP 가 받아서 로그를 남겨주는 방식으로 로그를 남길려고 했는데 log4j2 를 처음 쓰기도 하고 

이걸 만들면서 log4j2 부수고 싶었다.


먼저 LoggingAspect 생성

```java
package com.rc.raceproject.config;

  

import jakarta.servlet.http.HttpServletRequest;

import org.apache.logging.log4j.LogManager;

import org.apache.logging.log4j.Logger;

import org.apache.logging.log4j.ThreadContext;

import org.aspectj.lang.JoinPoint;

import org.aspectj.lang.annotation.*;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.stereotype.Component;

  

import java.io.File;

import java.util.Enumeration;

import java.util.HashMap;

import java.util.Map;

  

@Aspect

@Component

public class LoggingAspect {

  

    @Autowired

    private HttpServletRequest request;

  

    @Pointcut("execution(* com.rc.raceproject.controller..*(..)) && !@annotation(com.rc.raceproject.annotation.NoLogging)")

    protected void applicationControllerPackagePointcut(){}

  

    @Pointcut("execution(* com.rc.raceproject.service..*(..)) && !@annotation(com.rc.raceproject.annotation.NoLogging)")

    protected void applicationServicePackagePointcut(){}

  

    @Before("applicationControllerPackagePointcut()")

    public void beforeController(JoinPoint joinPoint) {

        logBefore(joinPoint, "controller");

    }

  

    @Before("applicationServicePackagePointcut()")

    public void beforeService(JoinPoint joinPoint) {

        logBefore(joinPoint, "service");

    }

  

    @AfterReturning(value = "applicationControllerPackagePointcut()", returning = "result")

    public void afterController(JoinPoint joinPoint, Object result) {

        logAfter(joinPoint, result, "controller");

    }

  

    @AfterReturning(value = "applicationServicePackagePointcut()", returning = "result")

    public void afterService(JoinPoint joinPoint, Object result) {

        logAfter(joinPoint, result, "service");

    }

  

    @AfterThrowing(value = "applicationControllerPackagePointcut()", throwing = "exception")

    public void afterThrowingController(JoinPoint joinPoint, Exception exception) {

        logAfter(joinPoint, exception, "controller");

    }

  

    @AfterThrowing(value = "applicationServicePackagePointcut()", throwing = "exception")

    public void afterThrowingService(JoinPoint joinPoint, Exception exception) {

        logAfter(joinPoint, exception, "service");

    }

  

    private void logBefore(JoinPoint joinPoint, String type) {

        String fullClassName = joinPoint.getSignature().getDeclaringTypeName();

        String className = joinPoint.getSignature().getDeclaringType().getSimpleName();

        String methodName = joinPoint.getSignature().getName();

        String clientIp = request.getRemoteAddr();

  

        // https header

        Map<String, String> headers = new HashMap<>();

        Enumeration<String> headerNames = request.getHeaderNames();

        while (headerNames.hasMoreElements()) {

            String headerName = headerNames.nextElement();

            headers.put(headerName, request.getHeader(headerName));

        }

  

        // log method parameter

        Map<String, Object> params = new HashMap<>();

        Enumeration<String> paramNames = request.getParameterNames();

        while (paramNames.hasMoreElements()) {

            String paramName = paramNames.nextElement();

            params.put(paramName, request.getParameter(paramName));

        }

  

        String reqLogDir = "req/" + type + "/" + className + "/" + methodName;

        createDirectories(reqLogDir);

        ThreadContext.put("headers", !headers.isEmpty() ? headers.toString() : null);

        ThreadContext.put("beforeClassName", className);

        ThreadContext.put("beforeMethodName", methodName);

        ThreadContext.put("clientIp", clientIp);

        Logger logger = LogManager.getLogger(fullClassName);

        logger.info(params.toString());

    }

  

    private void logAfter(JoinPoint joinPoint, Object object, String type) {

        String fullClassName = joinPoint.getSignature().getDeclaringTypeName();

        String className = joinPoint.getSignature().getDeclaringType().getSimpleName();

        String methodName = joinPoint.getSignature().getName();

        Logger logger = LogManager.getLogger(fullClassName);

  

        String resLogDir = "res/" + type + "/" + className + "/" + methodName;

        createDirectories(resLogDir);

        ThreadContext.put("afterClassName", className);

        ThreadContext.put("afterMethodName", methodName);

  

        if(object instanceof Exception) {

            logger.info("exception: " + (Exception) object);

        } else {

            logger.info("result: " + object);

        }

  

        ThreadContext.clearAll();

    }

  

    private void createDirectories(String dirPath) {

        String rootPath = System.getProperty("LOG_DIR");

        String fullPath = rootPath + "/" + dirPath;

        File dir = new File(fullPath);

        if (!dir.exists()) {

            dir.mkdirs();

        }

    }

}
```

이렇게 설정하고 


```java
@SpringBootApplication  
@EnableScheduling  
@EnableAspectJAutoProxy  
public class RaceProjectApplication {  
	public static void main(String[] args) {  
		SpringApplication.run(RaceProjectApplication.class, args);  
	}  
}
```

@EnableAspectJAutoProxy 를 설정


그리고 Before, After RollingAppender 로 파일 남길려고 했는데 에러가 계속 났다...
Folder 를 찾을 수 없다는 에러였는데 찾아보니 log4j2 는 폴더를 생성하는 기능은 없다는 걸 찾았다...

그래서 Aspect 부분에 폴더 생성하는 로직 추가
```java
private void createDirectories(String dirPath) {
        String rootPath = System.getProperty("LOG_DIR");
        String fullPath = rootPath + "/" + dirPath;
        File dir = new File(fullPath);
        if (!dir.exists()) {
            dir.mkdirs();
        }
  }
```


그리고 application 구동 시 root path 가 없는 경우에 추가를 해야하기 때문에

```java
@Component  
public class LogDirInitializer {  
		@PostConstruct  
		public void initialize() {  
			String logDir = System.getProperty("LOG_DIR");  
			File dir = new File(logDir);  
			if(!dir.exists()){  
			dir.mkdirs();  
			}  
		}  
}
```

이렇게 추가 하면 완성!

